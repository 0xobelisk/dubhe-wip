  // Copyright (c) Obelisk Labs, Inc.
  // SPDX-License-Identifier: Apache-2.0
  #[allow(unused_use)]
  
  /* Autogenerated file. Do not edit manually. */
  
  module dubhe::asset_pools {

  use sui::bcs::{to_bytes};

  use dubhe::table_id;

  use dubhe::dapp_service::{Self, DappHub};

  use dubhe::dapp_key;

  use dubhe::dapp_key::DappKey;

  const TABLE_NAME: vector<u8> = b"asset_pools";

  public struct AssetPools has copy, drop, store {
    pool_address: address,
    lp_asset: address,
    reserve0: u128,
    reserve1: u128,
    k_last: u256,
  }

  public fun new(pool_address: address, lp_asset: address, reserve0: u128, reserve1: u128, k_last: u256): AssetPools {
    AssetPools {
            pool_address,
            lp_asset,
            reserve0,
            reserve1,
            k_last,
        }
  }

  public fun pool_address(self: &AssetPools): address {
    self.pool_address
  }

  public fun lp_asset(self: &AssetPools): address {
    self.lp_asset
  }

  public fun reserve0(self: &AssetPools): u128 {
    self.reserve0
  }

  public fun reserve1(self: &AssetPools): u128 {
    self.reserve1
  }

  public fun k_last(self: &AssetPools): u256 {
    self.k_last
  }

  public fun update_pool_address(self: &mut AssetPools, pool_address: address) {
    self.pool_address = pool_address
  }

  public fun update_lp_asset(self: &mut AssetPools, lp_asset: address) {
    self.lp_asset = lp_asset
  }

  public fun update_reserve0(self: &mut AssetPools, reserve0: u128) {
    self.reserve0 = reserve0
  }

  public fun update_reserve1(self: &mut AssetPools, reserve1: u128) {
    self.reserve1 = reserve1
  }

  public fun update_k_last(self: &mut AssetPools, k_last: u256) {
    self.k_last = k_last
  }

  public fun get_table_id(): vector<u8> {
    table_id::encode(table_id::onchain_table_type(), TABLE_NAME)
  }

  public fun get_key_schemas(): vector<vector<u8>> {
    vector[b"address", b"address"]
  }

  public fun get_value_schemas(): vector<vector<u8>> {
    vector[b"address", b"address", b"u128", b"u128", b"u256"]
  }

  public fun get_key_names(): vector<vector<u8>> {
    vector[b"asset0", b"asset1"]
  }

  public fun get_value_names(): vector<vector<u8>> {
    vector[b"pool_address", b"lp_asset", b"reserve0", b"reserve1", b"k_last"]
  }

  public(package) fun register_table(dapp_hub: &mut DappHub, ctx: &mut TxContext) {
    let dapp_key = dapp_key::new();
    dapp_service::register_table(
            dapp_hub, 
            dapp_key,
            get_table_id(), 
            TABLE_NAME, 
            get_key_schemas(), 
            get_key_names(), 
            get_value_schemas(), 
            get_value_names(), 
            ctx
        );
  }

  public fun has(dapp_hub: &DappHub, asset0: address, asset1: address): bool {
    let mut key_tuple = vector::empty();
    key_tuple.push_back(to_bytes(&asset0));
    key_tuple.push_back(to_bytes(&asset1));
    dapp_service::has_record<DappKey>(dapp_hub, get_table_id(), key_tuple)
  }

  public fun ensure_has(dapp_hub: &DappHub, asset0: address, asset1: address) {
    let mut key_tuple = vector::empty();
    key_tuple.push_back(to_bytes(&asset0));
    key_tuple.push_back(to_bytes(&asset1));
    dapp_service::ensure_has_record<DappKey>(dapp_hub, get_table_id(), key_tuple)
  }

  public fun ensure_not_has(dapp_hub: &DappHub, asset0: address, asset1: address) {
    let mut key_tuple = vector::empty();
    key_tuple.push_back(to_bytes(&asset0));
    key_tuple.push_back(to_bytes(&asset1));
    dapp_service::ensure_not_has_record<DappKey>(dapp_hub, get_table_id(), key_tuple)
  }

  public fun has_pool_address(dapp_hub: &DappHub, asset0: address, asset1: address): bool {
    let mut key_tuple = vector::empty();
    key_tuple.push_back(to_bytes(&asset0));
    key_tuple.push_back(to_bytes(&asset1));
    dapp_service::has_field<DappKey>(dapp_hub, get_table_id(), key_tuple, 0)
  }

  public fun ensure_has_pool_address(dapp_hub: &DappHub, asset0: address, asset1: address) {
    let mut key_tuple = vector::empty();
    key_tuple.push_back(to_bytes(&asset0));
    key_tuple.push_back(to_bytes(&asset1));
    dapp_service::ensure_has_field<DappKey>(dapp_hub, get_table_id(), key_tuple, 0)
  }

  public fun ensure_not_has_pool_address(dapp_hub: &DappHub, asset0: address, asset1: address) {
    let mut key_tuple = vector::empty();
    key_tuple.push_back(to_bytes(&asset0));
    key_tuple.push_back(to_bytes(&asset1));
    dapp_service::ensure_not_has_field<DappKey>(dapp_hub, get_table_id(), key_tuple, 0)
  }

  public fun has_lp_asset(dapp_hub: &DappHub, asset0: address, asset1: address): bool {
    let mut key_tuple = vector::empty();
    key_tuple.push_back(to_bytes(&asset0));
    key_tuple.push_back(to_bytes(&asset1));
    dapp_service::has_field<DappKey>(dapp_hub, get_table_id(), key_tuple, 1)
  }

  public fun ensure_has_lp_asset(dapp_hub: &DappHub, asset0: address, asset1: address) {
    let mut key_tuple = vector::empty();
    key_tuple.push_back(to_bytes(&asset0));
    key_tuple.push_back(to_bytes(&asset1));
    dapp_service::ensure_has_field<DappKey>(dapp_hub, get_table_id(), key_tuple, 1)
  }

  public fun ensure_not_has_lp_asset(dapp_hub: &DappHub, asset0: address, asset1: address) {
    let mut key_tuple = vector::empty();
    key_tuple.push_back(to_bytes(&asset0));
    key_tuple.push_back(to_bytes(&asset1));
    dapp_service::ensure_not_has_field<DappKey>(dapp_hub, get_table_id(), key_tuple, 1)
  }

  public fun has_reserve0(dapp_hub: &DappHub, asset0: address, asset1: address): bool {
    let mut key_tuple = vector::empty();
    key_tuple.push_back(to_bytes(&asset0));
    key_tuple.push_back(to_bytes(&asset1));
    dapp_service::has_field<DappKey>(dapp_hub, get_table_id(), key_tuple, 2)
  }

  public fun ensure_has_reserve0(dapp_hub: &DappHub, asset0: address, asset1: address) {
    let mut key_tuple = vector::empty();
    key_tuple.push_back(to_bytes(&asset0));
    key_tuple.push_back(to_bytes(&asset1));
    dapp_service::ensure_has_field<DappKey>(dapp_hub, get_table_id(), key_tuple, 2)
  }

  public fun ensure_not_has_reserve0(dapp_hub: &DappHub, asset0: address, asset1: address) {
    let mut key_tuple = vector::empty();
    key_tuple.push_back(to_bytes(&asset0));
    key_tuple.push_back(to_bytes(&asset1));
    dapp_service::ensure_not_has_field<DappKey>(dapp_hub, get_table_id(), key_tuple, 2)
  }

  public fun has_reserve1(dapp_hub: &DappHub, asset0: address, asset1: address): bool {
    let mut key_tuple = vector::empty();
    key_tuple.push_back(to_bytes(&asset0));
    key_tuple.push_back(to_bytes(&asset1));
    dapp_service::has_field<DappKey>(dapp_hub, get_table_id(), key_tuple, 3)
  }

  public fun ensure_has_reserve1(dapp_hub: &DappHub, asset0: address, asset1: address) {
    let mut key_tuple = vector::empty();
    key_tuple.push_back(to_bytes(&asset0));
    key_tuple.push_back(to_bytes(&asset1));
    dapp_service::ensure_has_field<DappKey>(dapp_hub, get_table_id(), key_tuple, 3)
  }

  public fun ensure_not_has_reserve1(dapp_hub: &DappHub, asset0: address, asset1: address) {
    let mut key_tuple = vector::empty();
    key_tuple.push_back(to_bytes(&asset0));
    key_tuple.push_back(to_bytes(&asset1));
    dapp_service::ensure_not_has_field<DappKey>(dapp_hub, get_table_id(), key_tuple, 3)
  }

  public fun has_k_last(dapp_hub: &DappHub, asset0: address, asset1: address): bool {
    let mut key_tuple = vector::empty();
    key_tuple.push_back(to_bytes(&asset0));
    key_tuple.push_back(to_bytes(&asset1));
    dapp_service::has_field<DappKey>(dapp_hub, get_table_id(), key_tuple, 4)
  }

  public fun ensure_has_k_last(dapp_hub: &DappHub, asset0: address, asset1: address) {
    let mut key_tuple = vector::empty();
    key_tuple.push_back(to_bytes(&asset0));
    key_tuple.push_back(to_bytes(&asset1));
    dapp_service::ensure_has_field<DappKey>(dapp_hub, get_table_id(), key_tuple, 4)
  }

  public fun ensure_not_has_k_last(dapp_hub: &DappHub, asset0: address, asset1: address) {
    let mut key_tuple = vector::empty();
    key_tuple.push_back(to_bytes(&asset0));
    key_tuple.push_back(to_bytes(&asset1));
    dapp_service::ensure_not_has_field<DappKey>(dapp_hub, get_table_id(), key_tuple, 4)
  }

  public(package) fun delete(dapp_hub: &mut DappHub, asset0: address, asset1: address) {
    let mut key_tuple = vector::empty();
    key_tuple.push_back(to_bytes(&asset0));
    key_tuple.push_back(to_bytes(&asset1));
    dapp_service::delete_record<DappKey>(dapp_hub, dapp_key::new(), get_table_id(), key_tuple);
  }

  public fun get_pool_address(dapp_hub: &DappHub, asset0: address, asset1: address): address {
    let mut key_tuple = vector::empty();
    key_tuple.push_back(to_bytes(&asset0));
    key_tuple.push_back(to_bytes(&asset1));
    let value = dapp_service::get_field<DappKey>(dapp_hub, get_table_id(), key_tuple, 0);
    let mut bsc_type = sui::bcs::new(value);
    let pool_address = sui::bcs::peel_address(&mut bsc_type);
    pool_address
  }

  public(package) fun set_pool_address(
    dapp_hub: &mut DappHub,
    asset0: address,
    asset1: address,
    pool_address: address,
  ) {
    let mut key_tuple = vector::empty();
    key_tuple.push_back(to_bytes(&asset0));
    key_tuple.push_back(to_bytes(&asset1));
    let value = to_bytes(&pool_address);
    dapp_service::set_field(dapp_hub, dapp_key::new(), get_table_id(), key_tuple, 0, value);
  }

  public fun get_lp_asset(dapp_hub: &DappHub, asset0: address, asset1: address): address {
    let mut key_tuple = vector::empty();
    key_tuple.push_back(to_bytes(&asset0));
    key_tuple.push_back(to_bytes(&asset1));
    let value = dapp_service::get_field<DappKey>(dapp_hub, get_table_id(), key_tuple, 1);
    let mut bsc_type = sui::bcs::new(value);
    let lp_asset = sui::bcs::peel_address(&mut bsc_type);
    lp_asset
  }

  public(package) fun set_lp_asset(dapp_hub: &mut DappHub, asset0: address, asset1: address, lp_asset: address) {
    let mut key_tuple = vector::empty();
    key_tuple.push_back(to_bytes(&asset0));
    key_tuple.push_back(to_bytes(&asset1));
    let value = to_bytes(&lp_asset);
    dapp_service::set_field(dapp_hub, dapp_key::new(), get_table_id(), key_tuple, 1, value);
  }

  public fun get_reserve0(dapp_hub: &DappHub, asset0: address, asset1: address): u128 {
    let mut key_tuple = vector::empty();
    key_tuple.push_back(to_bytes(&asset0));
    key_tuple.push_back(to_bytes(&asset1));
    let value = dapp_service::get_field<DappKey>(dapp_hub, get_table_id(), key_tuple, 2);
    let mut bsc_type = sui::bcs::new(value);
    let reserve0 = sui::bcs::peel_u128(&mut bsc_type);
    reserve0
  }

  public(package) fun set_reserve0(dapp_hub: &mut DappHub, asset0: address, asset1: address, reserve0: u128) {
    let mut key_tuple = vector::empty();
    key_tuple.push_back(to_bytes(&asset0));
    key_tuple.push_back(to_bytes(&asset1));
    let value = to_bytes(&reserve0);
    dapp_service::set_field(dapp_hub, dapp_key::new(), get_table_id(), key_tuple, 2, value);
  }

  public fun get_reserve1(dapp_hub: &DappHub, asset0: address, asset1: address): u128 {
    let mut key_tuple = vector::empty();
    key_tuple.push_back(to_bytes(&asset0));
    key_tuple.push_back(to_bytes(&asset1));
    let value = dapp_service::get_field<DappKey>(dapp_hub, get_table_id(), key_tuple, 3);
    let mut bsc_type = sui::bcs::new(value);
    let reserve1 = sui::bcs::peel_u128(&mut bsc_type);
    reserve1
  }

  public(package) fun set_reserve1(dapp_hub: &mut DappHub, asset0: address, asset1: address, reserve1: u128) {
    let mut key_tuple = vector::empty();
    key_tuple.push_back(to_bytes(&asset0));
    key_tuple.push_back(to_bytes(&asset1));
    let value = to_bytes(&reserve1);
    dapp_service::set_field(dapp_hub, dapp_key::new(), get_table_id(), key_tuple, 3, value);
  }

  public fun get_k_last(dapp_hub: &DappHub, asset0: address, asset1: address): u256 {
    let mut key_tuple = vector::empty();
    key_tuple.push_back(to_bytes(&asset0));
    key_tuple.push_back(to_bytes(&asset1));
    let value = dapp_service::get_field<DappKey>(dapp_hub, get_table_id(), key_tuple, 4);
    let mut bsc_type = sui::bcs::new(value);
    let k_last = sui::bcs::peel_u256(&mut bsc_type);
    k_last
  }

  public(package) fun set_k_last(dapp_hub: &mut DappHub, asset0: address, asset1: address, k_last: u256) {
    let mut key_tuple = vector::empty();
    key_tuple.push_back(to_bytes(&asset0));
    key_tuple.push_back(to_bytes(&asset1));
    let value = to_bytes(&k_last);
    dapp_service::set_field(dapp_hub, dapp_key::new(), get_table_id(), key_tuple, 4, value);
  }

  public fun get(dapp_hub: &DappHub, asset0: address, asset1: address): (address, address, u128, u128, u256) {
    let mut key_tuple = vector::empty();
    key_tuple.push_back(to_bytes(&asset0));
    key_tuple.push_back(to_bytes(&asset1));
    let value_tuple = dapp_service::get_record<DappKey>(dapp_hub, get_table_id(), key_tuple);
    let mut bsc_type = sui::bcs::new(value_tuple);
    let pool_address = sui::bcs::peel_address(&mut bsc_type);
    let lp_asset = sui::bcs::peel_address(&mut bsc_type);
    let reserve0 = sui::bcs::peel_u128(&mut bsc_type);
    let reserve1 = sui::bcs::peel_u128(&mut bsc_type);
    let k_last = sui::bcs::peel_u256(&mut bsc_type);
    (pool_address, lp_asset, reserve0, reserve1, k_last)
  }

  public(package) fun set(
    dapp_hub: &mut DappHub,
    asset0: address,
    asset1: address,
    pool_address: address,
    lp_asset: address,
    reserve0: u128,
    reserve1: u128,
    k_last: u256,
  ) {
    let mut key_tuple = vector::empty();
    key_tuple.push_back(to_bytes(&asset0));
    key_tuple.push_back(to_bytes(&asset1));
    let value_tuple = encode(pool_address, lp_asset, reserve0, reserve1, k_last);
    dapp_service::set_record(dapp_hub, dapp_key::new(), get_table_id(), key_tuple, value_tuple);
  }

  public fun get_struct(dapp_hub: &DappHub, asset0: address, asset1: address): AssetPools {
    let mut key_tuple = vector::empty();
    key_tuple.push_back(to_bytes(&asset0));
    key_tuple.push_back(to_bytes(&asset1));
    let value_tuple = dapp_service::get_record<DappKey>(dapp_hub, get_table_id(), key_tuple);
    decode(value_tuple)
  }

  public(package) fun set_struct(dapp_hub: &mut DappHub, asset0: address, asset1: address, asset_pools: AssetPools) {
    let mut key_tuple = vector::empty();
    key_tuple.push_back(to_bytes(&asset0));
    key_tuple.push_back(to_bytes(&asset1));
    let value_tuple = encode_struct(asset_pools);
    dapp_service::set_record(dapp_hub, dapp_key::new(), get_table_id(), key_tuple, value_tuple);
  }

  public fun encode(
    pool_address: address,
    lp_asset: address,
    reserve0: u128,
    reserve1: u128,
    k_last: u256,
  ): vector<vector<u8>> {
    let mut value_tuple = vector::empty();
    value_tuple.push_back(to_bytes(&pool_address));
    value_tuple.push_back(to_bytes(&lp_asset));
    value_tuple.push_back(to_bytes(&reserve0));
    value_tuple.push_back(to_bytes(&reserve1));
    value_tuple.push_back(to_bytes(&k_last));
    value_tuple
  }

  public fun encode_struct(asset_pools: AssetPools): vector<vector<u8>> {
    encode(asset_pools.pool_address, asset_pools.lp_asset, asset_pools.reserve0, asset_pools.reserve1, asset_pools.k_last)
  }

  public fun decode(data: vector<u8>): AssetPools {
    let mut bsc_type = sui::bcs::new(data);
    let pool_address = sui::bcs::peel_address(&mut bsc_type);
    let lp_asset = sui::bcs::peel_address(&mut bsc_type);
    let reserve0 = sui::bcs::peel_u128(&mut bsc_type);
    let reserve1 = sui::bcs::peel_u128(&mut bsc_type);
    let k_last = sui::bcs::peel_u256(&mut bsc_type);
    AssetPools {
            pool_address,
            lp_asset,
            reserve0,
            reserve1,
            k_last,
        }
  }
}
